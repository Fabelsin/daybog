Створіть будь-який файл та засобами SELinux забороніть доступ
користувача root до нього і дозвольте повний доступ користувачу user666.

Повний протокол: SELinux — Блокування Root та доступ для User666
Мета завдання: Використовуючи мандатний контроль доступу (MAC) в SELinux, створити
файл, який не зможе прочитати суперкористувач (Root), але зможе прочитати звичайний
користувач (User666).
Етап 0: Підготовка "чистої" системи (Debian)
Оскільки ми починали з пустой системи, перша спроба налаштування провалилася через
відсутність інструментів. Виправляємо це.
# 1. Входимо як Root
su -
# 2. Оновлення списків пакетів
apt update
# 3. Встановлення необхідного ПЗ
# selinux-basics: базові налаштування захисту
# auditd: служба для запису логів (важлива для діагностики)
# policycoreutils-python-utils: містить команду 'semanage' (якої не вистачало)
# checkpolicy: компілятор для створення власних політик (.te файлів)
# setools: набір утиліт для аналізу політик
apt install selinux-basics selinux-policy-default auditd policycoreutils-python-utils checkpolicy setools -y
# 4. Активація SELinux та перезавантаження
# Ця команда додає параметри в завантажувач GRUB
selinux-activate
reboot
Етап 1: Вирішення системних помилок (Troubleshooting)
Після перезавантаження, при спробі використати semanage, ми отримали помилку:
ValueError: SELinux policy is not managed... або помилку про користувача sddm.
Проблема: У Debian (server version) відсутній користувач графічного інтерфейсу sddm, але
налаштування SELinux на нього посилаються. Це викликає паніку системи. Рішення: Створити
технічного користувача-заглушку.
su -
# Перевіряємо статус (має бути Enforcing)
getenforce
# Створюємо користувача sddm, щоб виправити помилку "user sddm not in password file"
# -r: створити як системного (без домашньої папки)
# -s /bin/false: заборонити вхід (для безпеки)
useradd -r -s /bin/false sddm
Етап 2: Створення та налаштування User666
Створюємо користувача та обмежуємо його правами SELinux. Тут ми також виправили
синтаксичну помилку.
1. Створення Linux-користувача:
# -m: створити домашню директорію
useradd -m -s /bin/bash user666
passwd user666
# (Введіть пароль, наприклад 123)
2. Прив'язка до SELinux (Mapping): Нюанс: Ми випадково ввели -a двічі (-a -a). Правильний
синтаксис — використовувати -s для вказівки користувача SELinux.
# Прив'язуємо user666 до обмеженого профілю 'user_u'.
# -a : (Add) додати запис
# -s : (Seuser) вказати SELinux-користувача 'user_u'
# Без цього User666 був би 'unconfined' (як root) і блокування не спрацювало б.
semanage login -a -s user_u user666
Етап 3: Написання спеціальної політики
Створюємо правило, яке робить файл невидимим для Root.
1. Створення файлу коду:
nano deny_root.te
Код політики:
module deny_root 1.0;
require {
 type user_t;
 class file { read write create open getattr unlink relabelto };
}
# Оголошуємо власний тип файлу.
# ВАЖЛИВО: Ми НЕ додаємо атрибут 'file_type'.
# Root (unconfined_t) має автоматичний доступ тільки до об'єктів, що мають атрибут
'file_type'.
# Відсутність цього атрибуту робить файл недоступним для Root.
type my_secret_t;
# Явно дозволяємо доступ для user666 (який працює в домені user_t)
allow user_t my_secret_t:file { read write create open getattr unlink relabelto };
2. Компіляція та встановлення:
# Компілюємо текст у бінарний модуль (.mod)
checkmodule -M -m -o deny_root.mod deny_root.te
# Пакуємо модуль у пакет політики (.pp)
semodule_package -o deny_root.pp -m deny_root.mod
# Інсталюємо пакет у ядро
semodule -i deny_root.pp
Етап 4: Парадокс "Root Locked Out" (Проблема з chcon)
Найцікавіший момент: Root втратив право навіть змінювати мітку файлу
1. Створення файлу:
touch /tmp/secret.txt
echo "User666 only!" > /tmp/secret.txt
# Даємо повні права Linux (777)
# Це доводить, що блокує саме SELinux, а не звичайні права доступу.
chmod 777 /tmp/secret.txt
2. Проблема: При спробі виконати chcon -t my_secret_t ... ми отримали помилку Permission
denied. Пояснення: Політика вже діє! Root не має права доступу до типу my_secret_t, тому він
навіть не може призначити цей тип файлу.
3. Вирішення (Тимчасове вимкнення):
# 1. Переводимо SELinux у режим "Permissive" (тільки логи, без блокування)
setenforce 0
# 2. Тепер мітку можна змінити (система пропустить це)
chcon -t my_secret_t /tmp/secret.txt
# 3. НЕГАЙНО вмикаємо захист назад!
setenforce 1
Етап 5: Фінальна перевірка (Нюанс з exit)
Тут ми зіткнулися з тим, що su - не завжди коректно перемикає контекст безпеки, тому
User666 теж отримував відмову.
Тест 1: Перевірка Root (Має бути ЗАБЛОКОВАНО)
cat /tmp/secret.txt
# Результат: Permission denied
# (Це перемога, Root не може прочитати файл 777)
Тест 2: Перевірка User666 (Правильний вхід) Нюанс: Не використовуйте команду su
всередині сесії root. Це може "успадкувати" обмеження. Треба зайти "чисто".
1. Вихід із системи: Введіть exit стільки разів, скільки потрібно, щоб побачити
запрошення входу vbox login:.
exit
exit
2. Вхід як User666: Логін: user666, Пароль: 123.
3. Перевірка:
# Перевіряємо контекст (має бути user_t)
id -Z
# Читаємо файл
cat /tmp/secret.txt
Результат: User666 only! (Успішний доступ).
Висновок: Завдання виконано. Ми довели перевагу MAC (SELinux) над DAC (Linux
permissions), створивши зону, недоступну навіть для адміністратора системи.
